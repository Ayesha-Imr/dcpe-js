<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: crypto/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: crypto/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import crypto from 'crypto';
import { create, all } from 'mathjs';
import { InvalidKeyError, DecryptError } from '../exceptions/index.js';
import { VectorEncryptionKey, ScalingFactor, EncryptionKey } from '../keys/index.js';

const math = create(all);

// Constants
const SHUFFLE_KEY = "One Ring to rule them all, One Ring to find them, One Ring to bring them all, and in the darkness bind them";

/**
 * Represents an authentication hash.
 */
class AuthHash {
    constructor(hashBytes) {
        if (!Buffer.isBuffer(hashBytes)) {
            throw new TypeError("AuthHash must be initialized with a Buffer");
        }
        if (hashBytes.length !== 32) {
            throw new Error("AuthHash must be 32 bytes long");
        }
        this.hashBytes = hashBytes;
    }

    getBytes() {
        return this.hashBytes;
    }

    equals(other) {
        return other instanceof AuthHash &amp;&amp; this.hashBytes.equals(other.hashBytes);
    }

    toString() {
        return `AuthHash(${this.hashBytes.toString('hex')})`;
    }
}

/**
 * Generates a random vector sampled from a multivariate normal distribution.
 * @param {number} dimensionality - The dimensionality of the vector.
 * @returns {Array&lt;number>} - The sampled vector.
 */
function sampleNormalVector(dimensionality) {
    // Using Box-Muller transform to generate normally distributed random values
    return Array.from({ length: dimensionality }, () => {
        // Box-Muller transform
        const u1 = Math.random();
        const u2 = Math.random();
        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
        return z0; // Mean 0, standard deviation 1
    });
}

/**
 * Samples a uniform random point between 0 and 1.
 * @returns {number} - The sampled point.
 */
function sampleUniformPoint() {
    return Math.random();
}

/**
 * Calculates a uniform point within an n-dimensional ball.
 * @param {ScalingFactor} scalingFactor - The scaling factor.
 * @param {number} approximationFactor - The approximation factor.
 * @param {number} uniformPoint - The sampled uniform point.
 * @param {number} dimensionality - The dimensionality of the vector.
 * @returns {number} - The calculated point.
 */
function calculateUniformPointInBall(scalingFactor, approximationFactor, uniformPoint, dimensionality) {
    const radius = (scalingFactor.getFactor() / 4) * approximationFactor;
    return radius * Math.pow(uniformPoint, 1 / dimensionality);
}

/**
 * Normalizes a sampled vector.
 * @param {Array&lt;number>} vector - The sampled vector.
 * @param {number} scale - The scaling factor.
 * @returns {Array&lt;number>} - The normalized vector.
 */
function normalizeVector(vector, scale) {
    const norm = math.norm(vector);
    return vector.map((val) => (val * scale) / norm);
}

/**
 * Generates a normalized noise vector for encryption.
 * @param {VectorEncryptionKey} key - The encryption key.
 * @param {Buffer} iv - The initialization vector.
 * @param {number} approximationFactor - The approximation factor.
 * @param {number} dimensionality - The dimensionality of the vector.
 * @returns {Array&lt;number>} - The noise vector.
 */
function generateNoiseVector(key, iv, approximationFactor, dimensionality) {
    if (!key) {
        throw new Error("Key is required for noise vector generation");
    }
    if (!iv || !Buffer.isBuffer(iv)) {
        throw new Error("IV must be a valid Buffer for noise vector generation");
    }
    if (!Number.isFinite(approximationFactor) || approximationFactor &lt;= 0) {
        throw new Error("Approximation factor must be a positive number");
    }
    if (!Number.isInteger(dimensionality) || dimensionality &lt;= 0) {
        throw new Error("Dimensionality must be a positive integer");
    }
    
    const normalVector = sampleNormalVector(dimensionality);
    const uniformPoint = sampleUniformPoint();
    const scaledPoint = calculateUniformPointInBall(key.scalingFactor, approximationFactor, uniformPoint, dimensionality);
    return normalizeVector(normalVector, scaledPoint);
}

/**
 * Creates a deterministic random number generator based on a key.
 * @param {EncryptionKey} key - The encryption key.
 * @returns {Function} - A random number generator function.
 */
function createRngFromKey(key) {
    const seed = key.getBytes().toString("hex");
    let h = 1779033703 ^ seed.length;
    for (let i = 0; i &lt; seed.length; i++) {
        h = Math.imul(h ^ seed.charCodeAt(i), 3432918353);
        h = (h &lt;&lt; 13) | (h >>> 19);
    }
    return function () {
        h = Math.imul(h ^ (h >>> 16), 2246822507);
        h = Math.imul(h ^ (h >>> 13), 3266489909);
        return ((h ^= h >>> 16) >>> 0) / 4294967296;
    };
}

/**
 * Shuffles an array deterministically based on a key.
 * @param {EncryptionKey} key - The encryption key used for deterministic shuffling.
 * @param {Array} inputArray - The array to shuffle.
 * @returns {Array} - The shuffled array.
 */
function shuffle(key, inputArray) {
    if (!key || !Array.isArray(inputArray)) {
        throw new Error("Invalid input to shuffle function");
    }

    // Create a deterministic random number generator based on the key
    const rng = createRngFromKey(key);

    // Create an array of indices and shuffle them
    const indices = inputArray.map((_, index) => index);
    for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
    }

    // Use the shuffled indices to reorder the input array
    return indices.map((index) => inputArray[index]);
}

/**
 * Unshuffles an array that was shuffled deterministically based on a key.
 * @param {EncryptionKey} key - The encryption key used for deterministic shuffling.
 * @param {Array} shuffledArray - The array to unshuffle.
 * @returns {Array} - The unshuffled array.
 */
/**
 * Reverses the shuffling of an array based on a given key.
 *
 * @param {string} key - A string used to seed the deterministic random number generator.
 * @param {Array} shuffledArray - The array that was previously shuffled and needs to be restored to its original order.
 * @returns {Array} - The original array restored to its unshuffled order.
 * @throws {Error} - Throws an error if the key is not provided or if the shuffledArray is not an array.
 *
 * @description
 * This function assumes that the array was shuffled using a deterministic algorithm
 * based on the same key. It recreates the shuffle permutation using a seeded random
 * number generator and then reverses the shuffle to restore the original order.
 *
 * Note: The function relies on the existence of `createRngFromKey`, which must generate
 * a deterministic random number generator seeded by the provided key.
 */
function unshuffle(key, shuffledArray) {
    if (!key || !Array.isArray(shuffledArray)) {
        throw new Error("Invalid input to unshuffle function");
    }

    // Create a deterministic random number generator based on the key
    const rng = createRngFromKey(key);

    // First recreate the exact same permutation that was used in the shuffle function
    const indices = Array.from({ length: shuffledArray.length }, (_, i) => i);
    for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
    }

    // Create a mapping from shuffled position to original position
    const reverseMap = new Array(indices.length);
    for (let i = 0; i &lt; indices.length; i++) {
        reverseMap[indices[i]] = i;
    }

    // Use the mapping to restore the original order
    return shuffledArray.map((_, i) => shuffledArray[reverseMap[i]]);
}

/**
 * Computes an authentication hash for a vector embedding.
 * @param {VectorEncryptionKey} key - The encryption key.
 * @param {number} approximationFactor - The approximation factor.
 * @param {Buffer} iv - The initialization vector.
 * @param {Array&lt;number>} encryptedVector - The encrypted vector.
 * @returns {AuthHash} - The computed authentication hash.
 */
function computeAuthHash(key, approximationFactor, iv, encryptedVector) {
    const hmac = crypto.createHmac('sha256', key.key.getBytes());
    hmac.update(Buffer.from(Float32Array.of(key.scalingFactor.getFactor()).buffer));
    hmac.update(Buffer.from(Float32Array.of(approximationFactor).buffer));
    hmac.update(iv);
    encryptedVector.forEach((val) => {
        hmac.update(Buffer.from(Float32Array.of(val).buffer));
    });
    return new AuthHash(hmac.digest());
}

/**
 * Encrypts a vector embedding.
 * @param {VectorEncryptionKey} key - The encryption key.
 * @param {number} approximationFactor - The approximation factor.
 * @param {Array&lt;number>} vector - The plaintext vector.
 * @returns {Object} - The encryption result containing ciphertext, IV, and auth hash.
 */
function encryptVector(key, approximationFactor, vector) {
    if (key.scalingFactor.getFactor() === 0) {
        throw new InvalidKeyError("Scaling factor cannot be zero");
    }

    const iv = crypto.randomBytes(12);
    const noiseVector = generateNoiseVector(key, iv, approximationFactor, vector.length);
    const ciphertext = vector.map((val, i) => key.scalingFactor.getFactor() * val + noiseVector[i]);

    if (!ciphertext.every((val) => Number.isFinite(val))) {
        throw new Error("Overflow error: Embedding or approximation factor too large.");
    }

    const authHash = computeAuthHash(key, approximationFactor, iv, ciphertext);

    return { ciphertext, iv, authHash };
}

/**
 * Decrypts an encrypted vector embedding.
 * @param {VectorEncryptionKey} key - The encryption key.
 * @param {number} approximationFactor - The approximation factor.
 * @param {Object} encryptedResult - The encryption result containing ciphertext, IV, and auth hash.
 * @returns {Array&lt;number>} - The decrypted vector.
 */
function decryptVector(key, approximationFactor, encryptedResult) {
    if (key.scalingFactor.getFactor() === 0) {
        throw new InvalidKeyError("Scaling factor cannot be zero");
    }

    const { ciphertext, iv, authHash } = encryptedResult;

    if (!computeAuthHash(key, approximationFactor, iv, ciphertext).equals(authHash)) {
        throw new DecryptError("Authentication hash mismatch");
    }

    const noiseVector = generateNoiseVector(key, iv, approximationFactor, ciphertext.length);
    return ciphertext.map((val, i) => (val - noiseVector[i]) / key.scalingFactor.getFactor());
}

export {
    AuthHash,
    encryptVector,
    decryptVector,
    computeAuthHash,
    generateNoiseVector,
    shuffle,
    unshuffle
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AuthHash.html">AuthHash</a></li><li><a href="ClientKeyProvider.html">ClientKeyProvider</a></li><li><a href="DCPEError.html">DCPEError</a></li><li><a href="EncryptionKey.html">EncryptionKey</a></li><li><a href="KeyIdHeader.html">KeyIdHeader</a></li><li><a href="KeyProvider.html">KeyProvider</a></li><li><a href="RagEncryptionClient.html">RagEncryptionClient</a></li><li><a href="ScalingFactor.html">ScalingFactor</a></li><li><a href="TspError.html">TspError</a></li><li><a href="VectorEncryptionKey.html">VectorEncryptionKey</a></li><li><a href="VectorMetadata.html">VectorMetadata</a></li></ul><h3>Global</h3><ul><li><a href="global.html#EdekType">EdekType</a></li><li><a href="global.html#PayloadType">PayloadType</a></li><li><a href="global.html#calculateUniformPointInBall">calculateUniformPointInBall</a></li><li><a href="global.html#computeAuthHash">computeAuthHash</a></li><li><a href="global.html#createRngFromKey">createRngFromKey</a></li><li><a href="global.html#decodeVersionPrefixedValue">decodeVersionPrefixedValue</a></li><li><a href="global.html#decryptVector">decryptVector</a></li><li><a href="global.html#encodeVectorMetadata">encodeVectorMetadata</a></li><li><a href="global.html#encryptVector">encryptVector</a></li><li><a href="global.html#generateNoiseVector">generateNoiseVector</a></li><li><a href="global.html#generateRandomKey">generateRandomKey</a></li><li><a href="global.html#normalizeVector">normalizeVector</a></li><li><a href="global.html#sampleNormalVector">sampleNormalVector</a></li><li><a href="global.html#sampleUniformPoint">sampleUniformPoint</a></li><li><a href="global.html#shuffle">shuffle</a></li><li><a href="global.html#unshuffle">unshuffle</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Apr 05 2025 16:12:24 GMT+0500 (Pakistan Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
