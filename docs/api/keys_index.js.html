<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: keys/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: keys/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import crypto from 'crypto';
import { InvalidKeyError } from '../exceptions/index.js';

/**
 * Represents a raw encryption key as bytes.
 */
class EncryptionKey {
    /**
     * @param {Buffer} keyBytes - The raw encryption key as a Buffer.
     */
    constructor(keyBytes) {
        if (!Buffer.isBuffer(keyBytes)) {
            throw new TypeError('EncryptionKey must be initialized with a Buffer');
        }
        this.keyBytes = keyBytes;
    }

    /**
     * Returns the raw key bytes.
     * @returns {Buffer}
     */
    getBytes() {
        return this.keyBytes;
    }

    /**
     * Checks equality with another EncryptionKey.
     * @param {EncryptionKey} other
     * @returns {boolean}
     */
    equals(other) {
        return other instanceof EncryptionKey &amp;&amp; this.keyBytes.equals(other.keyBytes);
    }

    /**
     * String representation of the EncryptionKey.
     * @returns {string}
     */
    toString() {
        return `EncryptionKey(bytes of length: ${this.keyBytes.length})`;
    }
}

/**
 * Represents the scaling factor used in vector encryption.
 */
class ScalingFactor {
    /**
     * @param {number} factor - The scaling factor as a float.
     */
    constructor(factor) {
        if (typeof factor !== 'number') {
            throw new TypeError('ScalingFactor must be initialized with a number');
        }
        this.factor = factor;
    }

    /**
     * Returns the scaling factor value.
     * @returns {number}
     */
    getFactor() {
        return this.factor;
    }

    /**
     * Checks equality with another ScalingFactor.
     * @param {ScalingFactor} other
     * @returns {boolean}
     */
    equals(other) {
        return other instanceof ScalingFactor &amp;&amp; this.factor === other.factor;
    }

    /**
     * String representation of the ScalingFactor.
     * @returns {string}
     */
    toString() {
        return `ScalingFactor(factor: ${this.factor})`;
    }
}

/**
 * Represents the combined key for vector encryption, including scaling factor and encryption key.
 */
class VectorEncryptionKey {
    /**
     * @param {ScalingFactor} scalingFactor - The scaling factor.
     * @param {EncryptionKey} key - The encryption key.
     */
    constructor(scalingFactor, key) {
        if (!(scalingFactor instanceof ScalingFactor)) {
            throw new TypeError('VectorEncryptionKey scalingFactor must be a ScalingFactor instance');
        }
        if (!(key instanceof EncryptionKey)) {
            throw new TypeError('VectorEncryptionKey key must be an EncryptionKey instance');
        }
        this.scalingFactor = scalingFactor;
        this.key = key;
    }

    /**
     * Derives a VectorEncryptionKey from a master secret, tenant ID, and derivation path.
     * @param {Buffer} secret - The master secret as a Buffer.
     * @param {string} tenantId - The tenant ID.
     * @param {string} derivationPath - The derivation path.
     * @returns {VectorEncryptionKey}
     */
    static deriveFromSecret(secret, tenantId, derivationPath) {
        if (!Buffer.isBuffer(secret)) {
            throw new TypeError('Secret must be a Buffer');
        }
        if (typeof tenantId !== 'string') {
            throw new TypeError('Tenant ID must be a string');
        }
        if (typeof derivationPath !== 'string') {
            throw new TypeError('Derivation Path must be a string');
        }

        const payload = Buffer.from(`${tenantId}-${derivationPath}`, 'utf-8');
        const hashResultBytes = crypto.createHmac('sha512', secret).update(payload).digest();
        return this.unsafeBytesToKey(hashResultBytes);
    }

    /**
     * Constructs a VectorEncryptionKey from raw bytes.
     * @param {Buffer} keyBytes - The raw bytes.
     * @returns {VectorEncryptionKey}
     * @throws {InvalidKeyError} If keyBytes is not long enough.
     */
    static unsafeBytesToKey(keyBytes) {
        if (keyBytes.length &lt; 35) {
            throw new InvalidKeyError('Key bytes must be at least 35 bytes long');
        }

        const scalingFactorBytes = keyBytes.slice(0, 3);
        const keyMaterialBytes = keyBytes.slice(3, 35);

        const scalingFactorU32 = parseInt(scalingFactorBytes.toString('hex'), 16);
        const scalingFactor = new ScalingFactor(scalingFactorU32);
        const encryptionKey = new EncryptionKey(keyMaterialBytes);

        return new VectorEncryptionKey(scalingFactor, encryptionKey);
    }

    /**
     * Checks equality with another VectorEncryptionKey.
     * @param {VectorEncryptionKey} other
     * @returns {boolean}
     */
    equals(other) {
        return (
            other instanceof VectorEncryptionKey &amp;&amp;
            this.scalingFactor.equals(other.scalingFactor) &amp;&amp;
            this.key.equals(other.key)
        );
    }

    /**
     * String representation of the VectorEncryptionKey.
     * @returns {string}
     */
    toString() {
        return `VectorEncryptionKey(scalingFactor=${this.scalingFactor}, key=${this.key})`;
    }
}

/**
 * Generates a cryptographically random EncryptionKey (32 bytes).
 * @returns {EncryptionKey}
 */
function generateRandomKey() {
    return new EncryptionKey(crypto.randomBytes(32));
}

export {
    EncryptionKey,
    ScalingFactor,
    VectorEncryptionKey,
    generateRandomKey
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AuthHash.html">AuthHash</a></li><li><a href="ClientKeyProvider.html">ClientKeyProvider</a></li><li><a href="DCPEError.html">DCPEError</a></li><li><a href="EncryptionKey.html">EncryptionKey</a></li><li><a href="KeyIdHeader.html">KeyIdHeader</a></li><li><a href="KeyProvider.html">KeyProvider</a></li><li><a href="RagEncryptionClient.html">RagEncryptionClient</a></li><li><a href="ScalingFactor.html">ScalingFactor</a></li><li><a href="TspError.html">TspError</a></li><li><a href="VectorEncryptionKey.html">VectorEncryptionKey</a></li><li><a href="VectorMetadata.html">VectorMetadata</a></li></ul><h3>Global</h3><ul><li><a href="global.html#EdekType">EdekType</a></li><li><a href="global.html#PayloadType">PayloadType</a></li><li><a href="global.html#calculateUniformPointInBall">calculateUniformPointInBall</a></li><li><a href="global.html#computeAuthHash">computeAuthHash</a></li><li><a href="global.html#createRngFromKey">createRngFromKey</a></li><li><a href="global.html#decodeVersionPrefixedValue">decodeVersionPrefixedValue</a></li><li><a href="global.html#decryptVector">decryptVector</a></li><li><a href="global.html#encodeVectorMetadata">encodeVectorMetadata</a></li><li><a href="global.html#encryptVector">encryptVector</a></li><li><a href="global.html#generateNoiseVector">generateNoiseVector</a></li><li><a href="global.html#generateRandomKey">generateRandomKey</a></li><li><a href="global.html#normalizeVector">normalizeVector</a></li><li><a href="global.html#sampleNormalVector">sampleNormalVector</a></li><li><a href="global.html#sampleUniformPoint">sampleUniformPoint</a></li><li><a href="global.html#shuffle">shuffle</a></li><li><a href="global.html#unshuffle">unshuffle</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Apr 05 2025 16:12:24 GMT+0500 (Pakistan Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
