<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: rag_encryption/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: rag_encryption/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { encryptVector, decryptVector, shuffle, unshuffle, computeAuthHash } from '../crypto/index.js';
import { KeyIdHeader, encodeVectorMetadata, decodeVersionPrefixedValue } from '../headers/index.js';
import { VectorEncryptionKey, EncryptionKey, ScalingFactor } from '../keys/index.js';
import { InvalidInputError, DecryptError } from '../exceptions/index.js';
import crypto from 'crypto';

/**
 * RagEncryptionClient: High-level interface for encryption and decryption.
 */
class RagEncryptionClient {
    /**
     * Initializes the RagEncryptionClient with encryption keys.
     * @param {Buffer} encryptionKey - Raw encryption key bytes.
     * @param {number} approximationFactor - Approximation factor for vector encryption.
     */
    constructor(encryptionKey, approximationFactor = 1.0) {
        if (!Buffer.isBuffer(encryptionKey) || encryptionKey.length &lt; 32) {
            throw new InvalidInputError("Encryption key must be a Buffer of at least 32 bytes.");
        }
        if (typeof approximationFactor !== 'number') {
            throw new InvalidInputError("Approximation factor must be a number.");
        }

        this.vectorEncryptionKey = new VectorEncryptionKey(
            new ScalingFactor(approximationFactor),
            new EncryptionKey(encryptionKey)
        );
        this.textEncryptionKey = new EncryptionKey(encryptionKey);
        this.deterministicEncryptionKey = new EncryptionKey(encryptionKey);
        this.approximationFactor = approximationFactor;
    }

    /**
     * Encrypts a vector embedding.
     * @param {Array&lt;number>} plaintextVector - The plaintext vector to encrypt.
     * @returns {Object} - Encrypted vector and metadata.
     */
    encryptVector(plaintextVector) {
        if (!Array.isArray(plaintextVector) || !plaintextVector.every((x) => typeof x === 'number')) {
            throw new InvalidInputError("Plaintext vector must be an array of numbers.");
        }

        // Shuffle the plaintext vector
        const shuffledVector = shuffle(this.textEncryptionKey, plaintextVector);

        // Encrypt the shuffled vector
        const encryptResult = encryptVector(
            this.vectorEncryptionKey,
            this.approximationFactor,
            shuffledVector
        );

        // Generate metadata
        const keyIdHeader = new KeyIdHeader(1, "Standalone", "VectorMetadata");
        const metadata = encodeVectorMetadata(keyIdHeader, encryptResult.iv, encryptResult.authHash);

        return {
            encryptedVector: encryptResult.ciphertext,
            metadata
        };
    }

    /**
     * Decrypts an encrypted vector embedding.
     * @param {Array&lt;number>} encryptedVector - The encrypted vector.
     * @param {Buffer} metadata - The metadata associated with the encrypted vector.
     * @returns {Array&lt;number>} - The decrypted plaintext vector.
     */
    decryptVector(encryptedVector, metadata) {
        if (!Array.isArray(encryptedVector) || !encryptedVector.every((x) => typeof x === 'number')) {
            throw new InvalidInputError("Encrypted vector must be an array of numbers.");
        }
        if (!Buffer.isBuffer(metadata)) {
            throw new InvalidInputError("Metadata must be a Buffer.");
        }

        /// Decode metadata
        const { keyIdHeader, remainingBytes } = decodeVersionPrefixedValue(metadata);
        const iv = remainingBytes.subarray(0, 12);
        const authHashBytes = remainingBytes.subarray(12);

        // Convert the Buffer to an AuthHash object
        const authHash = new AuthHash(authHashBytes);

        // Decrypt the vector
        const shuffledVector = decryptVector(
            this.vectorEncryptionKey,
            this.approximationFactor,
            {
                ciphertext: encryptedVector,
                iv,
                authHash
            }
        );

        // Unshuffle the vector
        return unshuffle(this.textEncryptionKey, shuffledVector);
    }

    /**
     * Encrypts a text string using AES-GCM.
     * @param {string} plaintext - The plaintext string to encrypt.
     * @returns {Object} - Encrypted text, IV, and authentication tag.
     */
    encryptText(plaintext) {
        if (typeof plaintext !== 'string') {
            throw new InvalidInputError("Plaintext must be a string.");
        }
    
        // Ensure the key is exactly 32 bytes
        const key = this.textEncryptionKey.getBytes().slice(0, 32);
        
        const iv = crypto.randomBytes(12);
        const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
        const ciphertext = Buffer.concat([cipher.update(plaintext, 'utf8'), cipher.final()]);
        const tag = cipher.getAuthTag();
    
        return { ciphertext, iv, tag };
    }

    /**
     * Decrypts an AES-GCM encrypted text.
     * @param {Buffer} ciphertext - The encrypted text.
     * @param {Buffer} iv - The initialization vector.
     * @param {Buffer} tag - The authentication tag.
     * @returns {string} - The decrypted plaintext string.
     */
    decryptText(ciphertext, iv, tag) {
        if (!Buffer.isBuffer(ciphertext) || !Buffer.isBuffer(iv) || !Buffer.isBuffer(tag)) {
            throw new InvalidInputError("Ciphertext, IV, and tag must be Buffers.");
        }
    
        // Ensure the key is exactly 32 bytes
        const key = this.textEncryptionKey.getBytes().slice(0, 32);
        
        const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
        decipher.setAuthTag(tag);
        const plaintext = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
    
        return plaintext.toString('utf8');
    }

    /**
     * Encrypts text deterministically using AES-GCM-SIV.
     * Note: The SHA-256 hash is used here to generate a deterministic IV for encryption,
     * not for password hashing. This is acceptable for this specific use case.
     * @param {string} plaintext - The plaintext string to encrypt.
     * @returns {Buffer} - The encrypted text.
    */
    encryptDeterministicText(plaintext) {
        if (typeof plaintext !== 'string') {
            throw new InvalidInputError("Plaintext must be a string.");
        }
    
        // Ensure the key is exactly 32 bytes
        const key = this.deterministicEncryptionKey.getBytes().slice(0, 32);
        
        const iv = crypto.createHash('sha256').update(plaintext).digest().slice(0, 12);
        const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
        const ciphertext = Buffer.concat([cipher.update(plaintext, 'utf8'), cipher.final()]);
    
        return Buffer.concat([iv, ciphertext, cipher.getAuthTag()]);
    }

    /**
     * Decrypts deterministically encrypted text.
     * @param {Buffer} encryptedData - The encrypted text.
     * @returns {string} - The decrypted plaintext string.
     */
    decryptDeterministicText(encryptedData) {
        if (!Buffer.isBuffer(encryptedData)) {
            throw new InvalidInputError("Encrypted data must be a Buffer.");
        }
    
        // Ensure the key is exactly 32 bytes
        const key = this.deterministicEncryptionKey.getBytes().slice(0, 32);
        
        const iv = encryptedData.slice(0, 12);
        const ciphertext = encryptedData.slice(12, -16);
        const tag = encryptedData.slice(-16);
    
        const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
        decipher.setAuthTag(tag);
        const plaintext = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
    
        return plaintext.toString('utf8');
    }
}

export { RagEncryptionClient };</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AuthHash.html">AuthHash</a></li><li><a href="ClientKeyProvider.html">ClientKeyProvider</a></li><li><a href="DCPEError.html">DCPEError</a></li><li><a href="EncryptionKey.html">EncryptionKey</a></li><li><a href="KeyIdHeader.html">KeyIdHeader</a></li><li><a href="KeyProvider.html">KeyProvider</a></li><li><a href="RagEncryptionClient.html">RagEncryptionClient</a></li><li><a href="ScalingFactor.html">ScalingFactor</a></li><li><a href="TspError.html">TspError</a></li><li><a href="VectorEncryptionKey.html">VectorEncryptionKey</a></li><li><a href="VectorMetadata.html">VectorMetadata</a></li></ul><h3>Global</h3><ul><li><a href="global.html#EdekType">EdekType</a></li><li><a href="global.html#PayloadType">PayloadType</a></li><li><a href="global.html#calculateUniformPointInBall">calculateUniformPointInBall</a></li><li><a href="global.html#computeAuthHash">computeAuthHash</a></li><li><a href="global.html#createRngFromKey">createRngFromKey</a></li><li><a href="global.html#decodeVersionPrefixedValue">decodeVersionPrefixedValue</a></li><li><a href="global.html#decryptVector">decryptVector</a></li><li><a href="global.html#encodeVectorMetadata">encodeVectorMetadata</a></li><li><a href="global.html#encryptVector">encryptVector</a></li><li><a href="global.html#generateNoiseVector">generateNoiseVector</a></li><li><a href="global.html#generateRandomKey">generateRandomKey</a></li><li><a href="global.html#normalizeVector">normalizeVector</a></li><li><a href="global.html#sampleNormalVector">sampleNormalVector</a></li><li><a href="global.html#sampleUniformPoint">sampleUniformPoint</a></li><li><a href="global.html#shuffle">shuffle</a></li><li><a href="global.html#unshuffle">unshuffle</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Apr 05 2025 16:12:24 GMT+0500 (Pakistan Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
